{
  "version": 3,
  "sources": ["../../langchain/dist/output_parsers/noop.js", "../../langchain/dist/chains/llm_chain.js"],
  "sourcesContent": ["import { BaseOutputParser } from \"@langchain/core/output_parsers\";\n/**\n * The NoOpOutputParser class is a type of output parser that does not\n * perform any operations on the output. It extends the BaseOutputParser\n * class and is part of the LangChain's output parsers module. This class\n * is useful in scenarios where the raw output of the Large Language\n * Models (LLMs) is required.\n */\nexport class NoOpOutputParser extends BaseOutputParser {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"default\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n    }\n    static lc_name() {\n        return \"NoOpOutputParser\";\n    }\n    /**\n     * This method takes a string as input and returns the same string as\n     * output. It does not perform any operations on the input string.\n     * @param text The input string to be parsed.\n     * @returns The same input string without any operations performed on it.\n     */\n    parse(text) {\n        return Promise.resolve(text);\n    }\n    /**\n     * This method returns an empty string. It does not provide any formatting\n     * instructions.\n     * @returns An empty string, indicating no formatting instructions.\n     */\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n", "import { BaseLanguageModel, } from \"@langchain/core/language_models/base\";\nimport { BasePromptTemplate } from \"@langchain/core/prompts\";\nimport { Runnable } from \"@langchain/core/runnables\";\nimport { BaseChain } from \"./base.js\";\nimport { NoOpOutputParser } from \"../output_parsers/noop.js\";\nfunction isBaseLanguageModel(llmLike) {\n    return typeof llmLike._llmType === \"function\";\n}\nfunction _getLanguageModel(llmLike) {\n    if (isBaseLanguageModel(llmLike)) {\n        return llmLike;\n    }\n    else if (\"bound\" in llmLike && Runnable.isRunnable(llmLike.bound)) {\n        return _getLanguageModel(llmLike.bound);\n    }\n    else if (\"runnable\" in llmLike &&\n        \"fallbacks\" in llmLike &&\n        Runnable.isRunnable(llmLike.runnable)) {\n        return _getLanguageModel(llmLike.runnable);\n    }\n    else if (\"default\" in llmLike && Runnable.isRunnable(llmLike.default)) {\n        return _getLanguageModel(llmLike.default);\n    }\n    else {\n        throw new Error(\"Unable to extract BaseLanguageModel from llmLike object.\");\n    }\n}\n/**\n * Chain to run queries against LLMs.\n *\n * @example\n * ```ts\n * import { LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = PromptTemplate.fromTemplate(\"Tell me a {adjective} joke\");\n * const llm = new LLMChain({ llm: new OpenAI(), prompt });\n * ```\n */\nexport class LLMChain extends BaseChain {\n    static lc_name() {\n        return \"LLMChain\";\n    }\n    get inputKeys() {\n        return this.prompt.inputVariables;\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"prompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"llm\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"llmKwargs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"text\"\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.prompt = fields.prompt;\n        this.llm = fields.llm;\n        this.llmKwargs = fields.llmKwargs;\n        this.outputKey = fields.outputKey ?? this.outputKey;\n        this.outputParser =\n            fields.outputParser ?? new NoOpOutputParser();\n        if (this.prompt.outputParser) {\n            if (fields.outputParser) {\n                throw new Error(\"Cannot set both outputParser and prompt.outputParser\");\n            }\n            this.outputParser = this.prompt.outputParser;\n        }\n    }\n    getCallKeys() {\n        const callKeys = \"callKeys\" in this.llm ? this.llm.callKeys : [];\n        return callKeys;\n    }\n    /** @ignore */\n    _selectMemoryInputs(values) {\n        const valuesForMemory = super._selectMemoryInputs(values);\n        const callKeys = this.getCallKeys();\n        for (const key of callKeys) {\n            if (key in values) {\n                delete valuesForMemory[key];\n            }\n        }\n        return valuesForMemory;\n    }\n    /** @ignore */\n    async _getFinalOutput(generations, promptValue, runManager) {\n        let finalCompletion;\n        if (this.outputParser) {\n            finalCompletion = await this.outputParser.parseResultWithPrompt(generations, promptValue, runManager?.getChild());\n        }\n        else {\n            finalCompletion = generations[0].text;\n        }\n        return finalCompletion;\n    }\n    /**\n     * Run the core logic of this chain and add to output if desired.\n     *\n     * Wraps _call and handles memory.\n     */\n    call(values, config) {\n        return super.call(values, config);\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        const valuesForPrompt = { ...values };\n        const valuesForLLM = {\n            ...this.llmKwargs,\n        };\n        const callKeys = this.getCallKeys();\n        for (const key of callKeys) {\n            if (key in values) {\n                if (valuesForLLM) {\n                    valuesForLLM[key] =\n                        values[key];\n                    delete valuesForPrompt[key];\n                }\n            }\n        }\n        const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);\n        if (\"generatePrompt\" in this.llm) {\n            const { generations } = await this.llm.generatePrompt([promptValue], valuesForLLM, runManager?.getChild());\n            return {\n                [this.outputKey]: await this._getFinalOutput(generations[0], promptValue, runManager),\n            };\n        }\n        const modelWithParser = this.outputParser\n            ? this.llm.pipe(this.outputParser)\n            : this.llm;\n        const response = await modelWithParser.invoke(promptValue, runManager?.getChild());\n        return {\n            [this.outputKey]: response,\n        };\n    }\n    /**\n     * Format prompt with values and pass to LLM\n     *\n     * @param values - keys to pass to prompt template\n     * @param callbackManager - CallbackManager to use\n     * @returns Completion from LLM.\n     *\n     * @example\n     * ```ts\n     * llm.predict({ adjective: \"funny\" })\n     * ```\n     */\n    async predict(values, callbackManager) {\n        const output = await this.call(values, callbackManager);\n        return output[this.outputKey];\n    }\n    _chainType() {\n        return \"llm\";\n    }\n    static async deserialize(data) {\n        const { llm, prompt } = data;\n        if (!llm) {\n            throw new Error(\"LLMChain must have llm\");\n        }\n        if (!prompt) {\n            throw new Error(\"LLMChain must have prompt\");\n        }\n        return new LLMChain({\n            llm: await BaseLanguageModel.deserialize(llm),\n            prompt: await BasePromptTemplate.deserialize(prompt),\n        });\n    }\n    /** @deprecated */\n    serialize() {\n        const serialize = \"serialize\" in this.llm ? this.llm.serialize() : undefined;\n        return {\n            _type: `${this._chainType()}_chain`,\n            llm: serialize,\n            prompt: this.prompt.serialize(),\n        };\n    }\n    _getNumTokens(text) {\n        return _getLanguageModel(this.llm).getNumTokens(text);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAQO,IAAM,mBAAN,cAA+B,iBAAiB;AAAA,EACnD,cAAc;AACV,UAAM,GAAG,SAAS;AAClB,WAAO,eAAe,MAAM,gBAAgB;AAAA,MACxC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO,CAAC,aAAa,kBAAkB,SAAS;AAAA,IACpD,CAAC;AACD,WAAO,eAAe,MAAM,mBAAmB;AAAA,MAC3C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AAAA,EACA,OAAO,UAAU;AACb,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,MAAM;AACR,WAAO,QAAQ,QAAQ,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,wBAAwB;AACpB,WAAO;AAAA,EACX;AACJ;;;ACvCA,SAAS,oBAAoB,SAAS;AAClC,SAAO,OAAO,QAAQ,aAAa;AACvC;AACA,SAAS,kBAAkB,SAAS;AAChC,MAAI,oBAAoB,OAAO,GAAG;AAC9B,WAAO;AAAA,EACX,WACS,WAAW,WAAW,SAAS,WAAW,QAAQ,KAAK,GAAG;AAC/D,WAAO,kBAAkB,QAAQ,KAAK;AAAA,EAC1C,WACS,cAAc,WACnB,eAAe,WACf,SAAS,WAAW,QAAQ,QAAQ,GAAG;AACvC,WAAO,kBAAkB,QAAQ,QAAQ;AAAA,EAC7C,WACS,aAAa,WAAW,SAAS,WAAW,QAAQ,OAAO,GAAG;AACnE,WAAO,kBAAkB,QAAQ,OAAO;AAAA,EAC5C,OACK;AACD,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC9E;AACJ;AAcO,IAAM,WAAN,MAAM,kBAAiB,UAAU;AAAA,EACpC,OAAO,UAAU;AACb,WAAO;AAAA,EACX;AAAA,EACA,IAAI,YAAY;AACZ,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,aAAa;AACb,WAAO,CAAC,KAAK,SAAS;AAAA,EAC1B;AAAA,EACA,YAAY,QAAQ;AAChB,UAAM,MAAM;AACZ,WAAO,eAAe,MAAM,mBAAmB;AAAA,MAC3C,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,UAAU;AAAA,MAClC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,OAAO;AAAA,MAC/B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,aAAa;AAAA,MACrC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,WAAO,eAAe,MAAM,gBAAgB;AAAA,MACxC,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,MACV,OAAO;AAAA,IACX,CAAC;AACD,SAAK,SAAS,OAAO;AACrB,SAAK,MAAM,OAAO;AAClB,SAAK,YAAY,OAAO;AACxB,SAAK,YAAY,OAAO,aAAa,KAAK;AAC1C,SAAK,eACD,OAAO,gBAAgB,IAAI,iBAAiB;AAChD,QAAI,KAAK,OAAO,cAAc;AAC1B,UAAI,OAAO,cAAc;AACrB,cAAM,IAAI,MAAM,sDAAsD;AAAA,MAC1E;AACA,WAAK,eAAe,KAAK,OAAO;AAAA,IACpC;AAAA,EACJ;AAAA,EACA,cAAc;AACV,UAAM,WAAW,cAAc,KAAK,MAAM,KAAK,IAAI,WAAW,CAAC;AAC/D,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,oBAAoB,QAAQ;AACxB,UAAM,kBAAkB,MAAM,oBAAoB,MAAM;AACxD,UAAM,WAAW,KAAK,YAAY;AAClC,eAAW,OAAO,UAAU;AACxB,UAAI,OAAO,QAAQ;AACf,eAAO,gBAAgB,GAAG;AAAA,MAC9B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,MAAM,gBAAgB,aAAa,aAAa,YAAY;AACxD,QAAI;AACJ,QAAI,KAAK,cAAc;AACnB,wBAAkB,MAAM,KAAK,aAAa,sBAAsB,aAAa,aAAa,yCAAY,UAAU;AAAA,IACpH,OACK;AACD,wBAAkB,YAAY,CAAC,EAAE;AAAA,IACrC;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,QAAQ,QAAQ;AACjB,WAAO,MAAM,KAAK,QAAQ,MAAM;AAAA,EACpC;AAAA;AAAA,EAEA,MAAM,MAAM,QAAQ,YAAY;AAC5B,UAAM,kBAAkB,EAAE,GAAG,OAAO;AACpC,UAAM,eAAe;AAAA,MACjB,GAAG,KAAK;AAAA,IACZ;AACA,UAAM,WAAW,KAAK,YAAY;AAClC,eAAW,OAAO,UAAU;AACxB,UAAI,OAAO,QAAQ;AACf,YAAI,cAAc;AACd,uBAAa,GAAG,IACZ,OAAO,GAAG;AACd,iBAAO,gBAAgB,GAAG;AAAA,QAC9B;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,cAAc,MAAM,KAAK,OAAO,kBAAkB,eAAe;AACvE,QAAI,oBAAoB,KAAK,KAAK;AAC9B,YAAM,EAAE,YAAY,IAAI,MAAM,KAAK,IAAI,eAAe,CAAC,WAAW,GAAG,cAAc,yCAAY,UAAU;AACzG,aAAO;AAAA,QACH,CAAC,KAAK,SAAS,GAAG,MAAM,KAAK,gBAAgB,YAAY,CAAC,GAAG,aAAa,UAAU;AAAA,MACxF;AAAA,IACJ;AACA,UAAM,kBAAkB,KAAK,eACvB,KAAK,IAAI,KAAK,KAAK,YAAY,IAC/B,KAAK;AACX,UAAM,WAAW,MAAM,gBAAgB,OAAO,aAAa,yCAAY,UAAU;AACjF,WAAO;AAAA,MACH,CAAC,KAAK,SAAS,GAAG;AAAA,IACtB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,QAAQ,QAAQ,iBAAiB;AACnC,UAAM,SAAS,MAAM,KAAK,KAAK,QAAQ,eAAe;AACtD,WAAO,OAAO,KAAK,SAAS;AAAA,EAChC;AAAA,EACA,aAAa;AACT,WAAO;AAAA,EACX;AAAA,EACA,aAAa,YAAY,MAAM;AAC3B,UAAM,EAAE,KAAK,OAAO,IAAI;AACxB,QAAI,CAAC,KAAK;AACN,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC5C;AACA,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC/C;AACA,WAAO,IAAI,UAAS;AAAA,MAChB,KAAK,MAAM,kBAAkB,YAAY,GAAG;AAAA,MAC5C,QAAQ,MAAM,mBAAmB,YAAY,MAAM;AAAA,IACvD,CAAC;AAAA,EACL;AAAA;AAAA,EAEA,YAAY;AACR,UAAM,YAAY,eAAe,KAAK,MAAM,KAAK,IAAI,UAAU,IAAI;AACnE,WAAO;AAAA,MACH,OAAO,GAAG,KAAK,WAAW,CAAC;AAAA,MAC3B,KAAK;AAAA,MACL,QAAQ,KAAK,OAAO,UAAU;AAAA,IAClC;AAAA,EACJ;AAAA,EACA,cAAc,MAAM;AAChB,WAAO,kBAAkB,KAAK,GAAG,EAAE,aAAa,IAAI;AAAA,EACxD;AACJ;",
  "names": []
}
